// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit_logs.sql

package db

import (
	"context"
	"database/sql"
)

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (
    tool_name,
    ip_address,
    user_agent,
    input_size_bytes,
    output_size_bytes,
    processing_time_ms,
    status,
    error_message
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, created_at, tool_name, ip_address, user_agent, input_size_bytes, output_size_bytes, processing_time_ms, status, error_message
`

type CreateAuditLogParams struct {
	ToolName         string         `json:"tool_name"`
	IpAddress        string         `json:"ip_address"`
	UserAgent        sql.NullString `json:"user_agent"`
	InputSizeBytes   sql.NullInt64  `json:"input_size_bytes"`
	OutputSizeBytes  sql.NullInt64  `json:"output_size_bytes"`
	ProcessingTimeMs sql.NullInt64  `json:"processing_time_ms"`
	Status           string         `json:"status"`
	ErrorMessage     sql.NullString `json:"error_message"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRowContext(ctx, createAuditLog,
		arg.ToolName,
		arg.IpAddress,
		arg.UserAgent,
		arg.InputSizeBytes,
		arg.OutputSizeBytes,
		arg.ProcessingTimeMs,
		arg.Status,
		arg.ErrorMessage,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ToolName,
		&i.IpAddress,
		&i.UserAgent,
		&i.InputSizeBytes,
		&i.OutputSizeBytes,
		&i.ProcessingTimeMs,
		&i.Status,
		&i.ErrorMessage,
	)
	return i, err
}

const getLogsByTool = `-- name: GetLogsByTool :many
SELECT id, created_at, tool_name, ip_address, user_agent, input_size_bytes, output_size_bytes, processing_time_ms, status, error_message FROM audit_logs
WHERE tool_name = ?
ORDER BY created_at DESC
LIMIT ?
`

type GetLogsByToolParams struct {
	ToolName string `json:"tool_name"`
	Limit    int64  `json:"limit"`
}

func (q *Queries) GetLogsByTool(ctx context.Context, arg GetLogsByToolParams) ([]AuditLog, error) {
	rows, err := q.db.QueryContext(ctx, getLogsByTool, arg.ToolName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.ToolName,
			&i.IpAddress,
			&i.UserAgent,
			&i.InputSizeBytes,
			&i.OutputSizeBytes,
			&i.ProcessingTimeMs,
			&i.Status,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentLogs = `-- name: GetRecentLogs :many
SELECT id, created_at, tool_name, ip_address, user_agent, input_size_bytes, output_size_bytes, processing_time_ms, status, error_message FROM audit_logs
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) GetRecentLogs(ctx context.Context, limit int64) ([]AuditLog, error) {
	rows, err := q.db.QueryContext(ctx, getRecentLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.ToolName,
			&i.IpAddress,
			&i.UserAgent,
			&i.InputSizeBytes,
			&i.OutputSizeBytes,
			&i.ProcessingTimeMs,
			&i.Status,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToolStats = `-- name: GetToolStats :one
SELECT 
    COUNT(*) as total_uses,
    SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END) as successful_uses,
    AVG(processing_time_ms) as avg_processing_time_ms,
    SUM(input_size_bytes) as total_input_bytes,
    SUM(output_size_bytes) as total_output_bytes
FROM audit_logs
WHERE tool_name = ?
`

type GetToolStatsRow struct {
	TotalUses           int64           `json:"total_uses"`
	SuccessfulUses      sql.NullFloat64 `json:"successful_uses"`
	AvgProcessingTimeMs sql.NullFloat64 `json:"avg_processing_time_ms"`
	TotalInputBytes     sql.NullFloat64 `json:"total_input_bytes"`
	TotalOutputBytes    sql.NullFloat64 `json:"total_output_bytes"`
}

func (q *Queries) GetToolStats(ctx context.Context, toolName string) (GetToolStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getToolStats, toolName)
	var i GetToolStatsRow
	err := row.Scan(
		&i.TotalUses,
		&i.SuccessfulUses,
		&i.AvgProcessingTimeMs,
		&i.TotalInputBytes,
		&i.TotalOutputBytes,
	)
	return i, err
}
